package main

import (
	"bufio"
	_ "embed"
	"encoding/xml"
	"flag"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"
	"time"

	junit "github.com/jstemmer/go-junit-report/v2/junit"
)

//go:embed style.css
var styles string

func printTest(s junit.Testsuite, c junit.Testcase, result *junit.Result, isFailure bool) {
	id := fmt.Sprintf("%s.%s.%s", s.Name, c.Classname, c.Name)

	class, text, content := func() (string, string, string) {
		switch {
		case isFailure:
			return "failed", "Fail", result.Data
		case c.Skipped != nil:
			return "skipped", "Skip", c.Skipped.Message
		default:
			return "passed", "Pass", ""
		}
	}()

	fmt.Fprintf(outputFile, "<div class='%s' id='%s'>\n", class, id)
	fmt.Fprintf(outputFile, "<a href='#%s'>%s/%s <span class='badge'>%s</span></a>\n", id, c.Classname, c.Name, text)
	fmt.Fprintf(outputFile, "<div class='expando'>\n")

	if len(content) > 0 {
		fmt.Fprintf(outputFile, "<div class='content'>%s</div>\n", content)
	}

	d, _ := time.ParseDuration(c.Time)

	fmt.Fprintf(outputFile, "<p class='duration' title='Test duration'>%v</p>\n", d)
	fmt.Fprintf(outputFile, "</div>\n")
	fmt.Fprintf(outputFile, "</div>\n")
}

type dummyCloser struct{}

func (*dummyCloser) Close() error {
	// we should not close standard streams
	return nil
}

type stdinDummyCloser struct {
	io.Reader
	dummyCloser
}

type stdoutDummyCloser struct {
	io.Writer
	dummyCloser
}

type writerWrapper struct {
	io.Writer
	close func() error
}

func (w *writerWrapper) Close() error {
	return w.close()
}

var (
	boostCompatible bool
	inputFilename   string
	outputFilename  string

	outputFile io.WriteCloser
)

func init() {
	flag.BoolVar(&boostCompatible, "boost_compatible", false, "Parse format generated by Boost")
	flag.StringVar(&inputFilename, "input", "", "Junit file. Will use stdin if not set")
	flag.StringVar(&outputFilename, "output", "", "Output HTML file. Will use stdout if not set")
}

func main() {
	flag.Parse()

	inputFile := func() io.ReadCloser {
		if len(inputFilename) == 0 {
			return &stdinDummyCloser{Reader: os.Stdin}
		}

		f, err := os.Open(inputFilename)
		if err != nil {
			panic(err)
		}

		return f
	}()

	defer inputFile.Close()

	outputFile = func() io.WriteCloser {
		if len(outputFilename) == 0 {
			return &stdoutDummyCloser{Writer: os.Stdout}
		}

		f, err := os.Create(outputFilename)
		if err != nil {
			panic(err)
		}

		b := bufio.NewWriter(f)

		return &writerWrapper{
			Writer: b,
			close: func() error {
				if err := b.Flush(); err != nil {
					return err
				}

				return f.Close()
			},
		}
	}()

	defer outputFile.Close()

	suites := func() []junit.Testsuite {
		var err error

		if !boostCompatible {
			suites := &junit.Testsuites{}

			if err = xml.NewDecoder(inputFile).Decode(suites); err == nil {
				return suites.Suites
			}
		} else {
			suites := []junit.Testsuite{}

			if err = xml.NewDecoder(inputFile).Decode(&suites); err == nil {
				return suites
			}
		}

		panic(err)
	}()

	fmt.Fprintln(outputFile, "<html>")
	fmt.Fprintln(outputFile, "<head>")
	fmt.Fprintln(outputFile, "<meta charset=\"UTF-8\">")
	fmt.Fprintln(outputFile, "<style>")
	fmt.Fprintln(outputFile, styles)
	fmt.Fprintln(outputFile, "</style>")
	fmt.Fprintln(outputFile, "</head>")
	fmt.Fprintln(outputFile, "<body>")

	failures, total := 0, 0

	for _, s := range suites {
		failures += s.Failures + s.Errors
		total += len(s.Testcases)

	}

	fmt.Fprintf(outputFile, "<p>%d of %d tests failed</p>\n", failures, total)

	for _, s := range suites {
		if s.Failures+s.Errors > 0 {
			printSuiteHeader(s)

			for _, c := range s.Testcases {
				if f := c.Failure; f != nil {
					printTest(s, c, c.Failure, true)
				}

				if e := c.Error; e != nil {
					printTest(s, c, c.Error, true)
				}
			}
		}
	}

	for _, s := range suites {
		printSuiteHeader(s)

		for _, c := range s.Testcases {
			if c.Failure == nil && c.Error == nil {
				printTest(s, c, nil, false)
			}
		}
	}

	fmt.Fprintln(outputFile, "</body>")
	fmt.Fprintln(outputFile, "</html>")
}

func printSuiteHeader(s junit.Testsuite) {
	fmt.Fprintln(outputFile, "<h4>")
	fmt.Fprintln(outputFile, s.Name)

	if s.Properties == nil {
		return
	}

	for _, p := range *s.Properties {
		if strings.HasPrefix(p.Name, "coverage.") {
			v, _ := strconv.ParseFloat(p.Value, 10)
			fmt.Fprintf(outputFile, "<span class='coverage' title='%s'>%.0f%%</span>\n", p.Name, v)
		}
	}
	fmt.Fprintln(outputFile, "</h4>")
}
